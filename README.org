#+begin_example
       _     __ _ _      _
  ___ | | __/ _(_) | ___| |_ __ _  __ _ ___
 / _ \| |/ / |_| | |/ _ \ __/ _` |/ _` / __|
| (_) |   <|  _| | |  __/ || (_| | (_| \__ \
 \___/|_|\_\_| |_|_|\___|\__\__,_|\__, |___/
                                  |___/
#+end_example

* NAME

=okfiletags= - manage tags on plain old files

* SYNOPSIS

  #+begin_example
  Usage: tags.rb [options]
    -l, --list [PATH]                List file tags (optionally for PATH)
    -a, --add-tags TAGS FILE         Add comma-separated TAGS to FILE
    -i FILE,                         Auto-complete tags and add them to FILE
        --add-tags-interactively
  #+end_example

* DESCRIPTION

=okfiletags= helps you organize your files by managing tags on them.
It works by adding/removing tags at the end of the filename after a
=--= qualifier. The implementation is OS-agnostic, so it should work
on Linux, macOS and Windows.

* EXAMPLES

Listing all tags in the current folder.

  #+begin_example
    $ touch foo
    $ touch bar.txt
    $ touch foobar--tag1,tag2.pdf
    $ touch baz--tag1.txt
    $ okfiletags -l
    tag1(2)
    tag2(1)
  #+end_example

Listing all tags for a given path glob (assuming the same data set as above).

#+begin_example
  $ okfiletags -l '*txt'
  tag1(1)
#+end_example

Adding tags to a file. NB: Tags are always unique.

#+begin_example
  okfiletags -a tag3,tag2 foobar--tag1,tag2.pdf
  $ ls foobar*
  foobar--tag1,tag2,tag3.pdf
#+end_example

Interactively adding tags (with auto-completion through readline) to a file.

#+begin_example
  $ okfiletags -i foo
  > t[TAB]
  tag1  tag2  tag3
  > tag2, new tag
  $ ls foo* | grep new
  foo--new tag,tag2
#+end_example

Renaming tags.

#+begin_example
  $ okfiletags -l
  200ok_expense(8)
  business_card(4)
  $ okfiletags -r 200ok_expense "200ok,expense"
  $ okfiletags -l
  expense(8)
  200ok(8)
  business_card(4)
#+end_example

Remove a tag from a file.

#+begin_example
  $ find . | grep business_card | head -n 1
  ./archiv/Cyrill_Schwitter--business_card,somedia,seo.pdf
  $ okfiletags -d seo ./archiv/Cyrill_Schwitter--business_card,somedia,seo.pdf
  $ find . | grep business_card | head -n 1
  ./archiv/Cyrill_Schwitter--business_card,somedia.pdf
#+end_example

* INSTALLATION

=okfiletags= is implemented in [[https://www.ruby-lang.org/en/][Ruby]], dependencies are managed with [[https://bundler.io/][bundler]].

  #+begin_example
    git clone https://github.com/200ok-ch/okfiletags.git
    cd okfiletags
    bundle
  #+end_example

* TESTS

  Tests are implemented with [[https://rspec.info/][RSpec]] and can be run like this:

#+begin_src shell
  $ rpsec spec
  .....

  Finished in 0.00351 seconds (files took 0.06834 seconds to load)
  5 examples, 0 failures
#+end_src

* NOTES

Software systems come and go. It is easy to lose important data in
(proprietary) legacy systems. Flat files, however, are likely a
concept that's going to stay; at least they [[https://en.wikipedia.org/wiki/Computer_file#Storage][have been around since
1961]]. Additional benefits of using plain old files are:

- They are (mostly) platform independent.
- They can be accessed by a wide array of software
  - They do not require a specific UI.
  - They do not require the use a database (apart from the filesystem
    itself, of course).
- They can be transported independently from the software that captured/created them.
- They are not proprietary.

At [[https://200ok.ch/][200ok]], we develop various Free Software projects that work on plain
old files:

- [[https://github.com/200ok-ch/organice/][organice]]: An implementation of Org mode without the dependency of
  Emacs - built for mobile and desktop browsers.
- [[https://github.com/200ok-ch/okdoc][okdoc]]: A document scanning and archiving solution (which works well
  with =okfiletags=).


* SEE ALSO

[[http://tmsu.org/][tmsu]], [[https://www.tagspaces.org/][tagspaces]]
